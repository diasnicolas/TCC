\documentclass[tc,openright]{iiufrgs}
\usepackage[T1]{fontenc}        % pacote para conj. de caracteres correto
\usepackage[utf8]{inputenc}   % pacote para acentua\c c\~ ao
\usepackage{graphicx}           % pacote para importar figuras
\usepackage{times}              % pacote para usar fonte Adobe Times
\usepackage{multirow}
\usepackage{subfigure}
\usepackage{listings}
\usepackage{scalefnt}
\usepackage[brazilian]{babel}
\usepackage{tabularx}
%\usepackage{hyperref}
%\usepackage{float}

\bibliographystyle{abnt}
%\bibliographystyle{apalike}

\hyphenation{en-si-na-men-tos a-gra-de-ci-men-to de-se-nha-dos}

\title{Framework AOP utilizando técnicas de Byte Code Engineering}

\author{Bento}{Nicolas}

\advisor[Prof.]{Torres}{Márcio}

\date{fevereiro}{2014}

\location{Rio Grande}{RS}

\renewcommand{\nominata}{
        UNIVERSIDADE FEDERAL DO RIO GRANDE\\
        Reitor: Prof. Cleuza Maria Sobral Dias\\
        Pró-Reitor de Graduaçăo: Prof. Denise Varella Martinez\\
        Coordenador do curso: Prof. Tiago Lopes Telecken\\
}

\keyword{AOP, Byte Code Engineering, Meta-programação, Framework, Soc}

\begin{document}

\maketitle

\begin{folhadeaprovacao}
Monografia sob o título \textit{"Framework AOP utilizando técnicas de Byte Code Engineering"}, defendida por Nicolas Dias Bento e aprovada em ?? de ?? de ???, em Rio Grande, estado do Rio Grande do Sul, pela banca examinadora constituída pelos professores:
 \assinatura{Prof. Márcio Torres\\ Orientador}
 \assinatura{Prof. NOME\\ IFRS - Campus Rio Grande }
 \assinatura{Prof. NOME\\ IFRS - Campus Rio Grande } 
\end{folhadeaprovacao}

\clearpage

\begin{flushright}
\mbox{}\vfill
{\sffamily\itshape
"A mente que se abre a uma nova ideia jamais volta ao seu tamanho original."\\}
--- \textsc{Albert Einstein}
\end{flushright}

\chapter*{Agradecimentos}

Agradecimentos ...

\tableofcontents

\begin{listofabbrv}{SPMD}
	\item[AOP] Programação Orientada a Aspectos (\textit{Aspect Oriented Programming})
	\item[SoC] Separação de interesses (\textit{Separation of concerns})
	\item[OOP] Programação Orientada a Objetos (\textit{Object Oriented Programming})
	\item[PARC] Centro de Pesquisa Palo Alto (\textit{Palo Alto Research Center})
	\item[SQL]  Linguagem de Consulta Estruturada (\textit{Structured Query Language})
	\item[YAGNI] Você não vai precisar dele (\textit{You aren’t gonna need it})
	\item[XP] Programação Extrema (\textit{Extreme Programming})
\end{listofabbrv}

\listoffigures

\listoftables

\begin{abstract}

Resumo ...

\end{abstract}

\chapter{Introdução}

\chapter{Aspect Oriented Programming}

Neste capítulo será abordado de forma geral o paradigma de programação orientada a aspectos, trazendo de forma objetiva as informações necessárias para a superficial compreensão desta abordagem.
\section{O que é?}
AOP é um paradigma de programação que foi contruído tomando como base outros paradigmas(OOP e \textit{procedural programming}), cujo o principal objetivo seria a modularização de interesses transversais, utilizando um dos paradigmas base na implementação dos interesses centrais. A forma como AOP e o paradigma base se integram se dá com a utilização de aspectos que determinam a forma como os diferentes módulos se relacionam entre si na formação do sistema final. \cite{laddad2003aspectj}

\section{História}
Após um grande período de estudos, pesquisadores chegaram a conclusão que para desenvolver um software de qualidade era fundamental separar os interesses do sistema, ou seja, deveria então ser aplicado o princípio de \textit{Separation of Concerns} (SoC)\footnote{Para saber mais sobre SoC consulte o Glossário.}. Em 1972, David Parnas escreveu um artigo, que tinha como  proposta aplicar SoC através de um processo de modularização, onde cada módulo deveria esconder as suas decisões de outros módulos.Passado alguns anos, pesquisadores continuaram a estudar diversas formas de separação de interesses. OOP foi a melhor, se tratando de separação de interesses centrais, mas quando se tratava de interesses transversais, acabava deixando a desejar. Diversas metodologias— \textit{generative programming, meta-programming, reflective programming, compositional filtering, adaptive programming, subject-oriented programming, aspect oriented programming,} e  \textit{intentional programming}— surgiram como possíveis abordagens para modularização de interesses transversais. AOP acabou se tornando a mais popular entre elas. \cite{laddad2003aspectj}

Em 1997 Gregor Kiczales e sua equipe descreveram de forma sólida o conceito de Programação Orientada a Aspectos, durante um trabalho de pesquisa realizado pelo PARC, uma subsidiária da \textit{Xerox Corporation}. O documento descreve uma solução complementar a OOP, ou seja, seriam utilizados "aspectos", que iriam encapsular as preocupações transversais, de forma a garantir a reutilização por outros módulos de um sistema.Sugeriu também diversas implementações de AOP, servindo como base para a criação do AspectJ\footnote{No final dos anos 90, a Xerox Corporation, transferiu o projeto AspectJ para a comunidade Open Source em eclipse.org.}, uma linguagem AOP muito difundida nos dias de hoje.\cite{groves2013aop}

\section{Principais conceitos}

Para entender melhor o funcionamento de AOP, é preciso compreender seus principais conceitos. 

Os 4 principais conceitos de AOP são:

\begin{itemize}
\item Aspecto (\textit{aspect}) - pode ser definido como um interesse transversal, ou seja, interesse onde sua implementação é espalhada por diversos módulos ou componentes de um sistema.
\item Ponto de junção (\textit{joinpoint}) - podem ser definidos basicamente como pontos bem definidos na execução de um programa.
\item Ponto de corte (\textit{pointcut}) - em AOP um \textit{pointcut} pode ser representado como um agrupamento de pontos de junção.
\item Conselho (\textit{advice}) - é a implementação de determinado interesse transversal, sendo executado quando determinado \textit{pointcut} é ativado, podendo ser executado antes(\textit{before}), durante (\textit{around}) ou depois (\textit{after}) da execução de um ponto de junção.
\end{itemize}

Podemos também comparar os conceitos de AOP com os principais conceitos de OOP:

\begin{table}[ht]
	\centering
	\caption{Comparação entre conceitos de AOP e OOP}
	\begin{tabular}[h]{c l}
		\hline 
		\textbf{AOP} & \textbf{OOP} \\
		\hline
		\textit{Aspect}&Classe \\
		\textit{Advice}&Método \\
		\textit{Joinpoint}&Atributo \\
		\hline
	\end{tabular}
	\label{tab:classificacaoEtq}
\end{table}

\textit{Pointcut} não se encaixa em nenhum conceito de orientação a objetos, mas podemos comparar um \textit{pointcut} com um gatilho(\textit{trigger}) da linguagem SQL (\textit{Structured Query Language}).

\section{Benefícios de AOP}

Em programação podemos dizer que cada paradigma tem seus prós e contras, sendo assim dificilmente encontraremos uma metodologia que resolva todos os nossos problemas da melhor maneira.Com AOP não é diferente, mas devemos considerar sua larga escala de benefícios:

\begin{itemize}
\item Separação de interesses e Alta modularização - com AOP podemos separar o projeto em módulos responsáveis por implementar apenas os interesses centrais do sistema, possuindo assim um acoplamento mínimo que extingui o codigo duplicado, fazendo com o sistema fique muito mais fácil de entender e manter, colocando os interesses transversais (aspectos) em módulos completamente diferentes.\cite{laddad2003aspectj} 
\item Fácil evolução - utilizando AOP o sistema fica muito mais flexível quando se trata da adição de novas funcionalidades, fazendo com que a resposta às exigências se tornem mais rápidas.
\item Foco na prioridade - o arquiteto do projeto pode se concentar nos requisitos básicos atuais do sistema, os novos requisitos que abordam interesses transverssais poderão ser tatados fácilmente com a criação de novos aspectos. AOP trabalha em harmonia com metodos agéis, por exemplo apóia a prática YAGNI(\textit{"You aren’t gonna need it"}) \footnote{Em português significa "Você não vai precisar dele". Para saber mais sobre YAGNI consulte o Glossário.}, do \textit{Extreme Programming}(XP)\footnote{É um dos metodos agéis mais utilizados na atualidade.}.\cite{laddad2003aspectj} 
\item Maior reutilização de código - a chave para a reutização de código definitiva é uma implementação flexível, com AOP é possível pois cada aspecto é implementado como um módulo distinto, se tornando adaptavél a implementações equivalentes convencionais.\cite{laddad2003aspectj} 
\item Aumento na produtividade - o ciclo do projeto se torna mais rápido, a grande reutilização usada em AOP, faz com que tempo de desenvolvimento seja reduzido, diminuindo também o tempo de implantação e o tempo de resposta às novas exigências de mercado. \cite{laddad2003aspectj} 
\item Redução de custos e aumento da qualidade - com a implementação dos interesses transversais em módulos distintos, o custo de implementação cai bastante, fazendo com que o desenvolvedor concetre-se mais nos interesses centrais, criando um produto de qualidade e com o custo reduzido.
\end{itemize}

\chapter{Byte Code Engineering}

\chapter{Framework que será usado}

\chapter{Meta-Programação}

\section{Anotações}

\section{Reflexão}

\chapter{Soluções Existentes}

\section{PostSharp}

\section{AspectJ}

\chapter{O Framework}

\section{Análise e projeto}

\section{Implementação}

\chapter{Estudo de caso - Instrumentação}

\chapter{Conclusão}

Conclusões ...

\bibliography{bibliografia}

\chapter*{Glossário}

\begin{description}
	\item[SoC] è um princípio de projeto, criado com a finalidade de subdividir o problema em conjuntos de interesses tornando a resolução do problema mais fácil.Cada interesse fornece uma funcionalidade distinta, podendo ser validado independentemente das regras negócio.\cite{pressman2010engineering}
	\item [YAGNI] é um princípio de projeto, bastante usado em equipes XP , cuja principal finalidade é implementar apenas o necessário, ou seja, a melhor maneira de implementar o código rapidamente é implementar menos.
	\item[Extreme Programming] XP é um estilo de desenvolvimento de software com em excelentes técnicas de programação, comunicação clara e trabalho em equipe, que permite grande produtividade no desenvolvimento. \cite{beck2004extreme}
\end{description}

\appendix

\end{document}

